Map集合 <key,value>

###1、HashMap
####数据结构：数组 + 单向链表 + 红黑树

数组 -> 有默认容量16 -> 扩容阈值为原容量*负载因子0.75 -> 扩容为原来的两倍

添加数据的时候计算数组下标公式hash(key) & (length - 1)等同于hash(key) % length  

等同于的前提条件为length必须是2的次幂，并且&运算比取模运算要快

负载因子为0.75是取了一个时间和空间上的折中，如果为0.5，那么几乎一半的内存是浪费的，如果是1，那么比较容易产生哈希冲突，从而生成链表，导致查询变慢

扩容为什么是原来的两倍，上面说了一点，计算数组下标快一点，

二一个是当扩容的时候，需要重新计算数组下表，那么链表里节点key的hash值是一样的，如果扩容为原来的两倍，那么二进制下进行下标运算，只需要考虑高一位的计算结果，如果为0，则代表在原来位置，如果为1则代表扩容之后（原数组长度+原下标长度）的下标位置，比如一个元素在下标为2的位置，如果计算结果为0，那么在新数组下还是在2位置，如果为1，则在2+16=18的下标位置

所以它是一个无序的，因为下标是计算出来的，也是不可重复的，因为key的hash值是一样的话会把value覆盖掉，如果key的hash值不一样，但是计算的下标一样的话，那么就产生hash冲突，生成链表，当链表长度>=7并且数组长度小于64的时候会生成红黑树

binCount >= TREEIFY_THRESHOLD - 1 大于等于7 

(n = tab.length) < MIN_TREEIFY_CAPACITY) 数组长度小于64

在jdk1.7的时候扩容时链表采用头插法，多并发情况下同时发生扩容的时候，内存地址元素会形成环（互相指向），所以在1.8的时候采用尾插法

###2、TreeMap
####数据结构：树
会对key进行排序